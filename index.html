<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>エクサスケイル防具 回路シミュレーター</title>
  <style>
body {
    font-family: monospace;
    padding: 20px;
    max-width: 1200px;
    margin: auto;
    background: #fff;
    color: #000;
    text-align: center;
}

h3 {
    text-align: left;
    margin-bottom: 4px;
}

/* ======== コンテナ ======== */
.container {
    display: flex;
    align-items: flex-start;
    justify-content: center;
    gap: 20px;
}

.description-column {
    flex: 0 0 450px;
    display: flex;
    flex-direction: column;
    font-size: 14px;
    gap: 12px;
    align-items: flex-end;
}

.left-frame {
    display: grid;
    grid-template-columns: repeat(2, auto);
    column-gap: 60px;  
    row-gap: 0; 
    height: 750px;
    align-items: flex-start;
    flex: 0 0 500px;
    background: #f5f5f5;
    padding: 16px;
    border-radius: 10px;
    border: 2px solid #333;
    box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
}

.side {
    flex: 0 0 350px;
    max-width: 350px;
    height: 750px;
    background: #f5f5f5;
    padding: 16px;
    border-radius: 10px;
    border: 2px solid #333;
    box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
    align-self: flex-start;
}

/* ======== ボード ======== */
.board-wrap {
    text-align: center;
    background: #f5f5f5;
    padding: 12px;
    border-radius: 10px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    margin-bottom: 0px;
}

.board {
    display: grid;
    grid-template-columns: repeat(4, 56px);
    grid-template-rows: repeat(4, 56px);
    gap: 2px;
    padding: 5px;
    background: #e0e0e0;
    border-radius: 5px;
    margin: 0 auto;
    flex-shrink: 0;
}

/* ======== セル ======== */
.cell {
    position: relative;
    border: 1px solid #333;
    font-size: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    user-select: none;
    background: #fff;
    border-radius: 5px;
    font-weight: bold;
}

.symbol-display {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
}

.number-display {
    position: absolute;
    bottom: 2px;
    right: 2px;
    font-size: 11px;
    color: #000;
}

.img {
    width: 52px;
    object-fit: contain;
    pointer-events: none;
    border-radius: 5px;
}

.highlight-red {
    background: #fff0f0;
    color: #ff6666;
    box-shadow: 0 0 30px #ff6666;
}

.highlight-blue {
    background: #f0f8ff;
    color: #3399ff;
    box-shadow: 0 0 30px #66b3ff;
}

.highlight-green {
    background: #f0fff4;
    color: #33cc88;
    box-shadow: 0 0 30px #66ffaa;
}

/* ======== 色/部位 ======== */
.panel {
    display: flex;
    gap: 15px;
    justify-content: center;
    margin-bottom: 6px;
}

/* ======== てんぷれ ======== */
.template-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
  justify-content: center;
  margin-bottom: 10px;
}

.template-btn {
  width: 48px;
  height: 48px;
  border: 1px solid #333;
  display: flex;
  background: #fff;
  color: #000;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  user-select: none;
  font-family: monospace;
  font-size: 26px;
  margin: 9px;
  border-radius: 5px;
}

.template-btn.selected.red-active {
  background: #fff0f0;
  color: #ff6666;
  box-shadow: 0 0 15px #ff6666;
}

.template-btn.selected.blue-active {
  background: #f0f8ff;
  color: #3399ff;
  box-shadow: 0 0 15px #3399ff;
}

.template-btn.selected.green-active {
  background: #f0fff4;
  color: #33cc88;
  box-shadow: 0 0 15px #33cc88;
}

.template-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 6px;
}

.template-header h3 {
  margin: 0;
}

.template-pager {
  display: flex;
  align-items: center;
  gap: 6px;
}

.pager button {
  height: 24px;
  padding: 0 5px;
  cursor: pointer;
  background: #fff;
  border: 1px solid #333;
  border-radius: 4px;
}

.pager span {
  font-size: 12px;
  min-width: 50px;
  text-align: center;
}

/* ======== 色選択 ======== */
.color-btn {
  width: 48px;
  height: 48px;
  border: 1px solid #333;
  font-size: 18px;
  background: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  user-select: none;
  border-radius: 5px;
}

.color-btn.active {
  box-shadow: 0 0 15px #3399ff;
  font-weight: bold;
}
.color-btn.active[data-color="red"] {
  color: #ff6666;
  box-shadow: 0 0 15px #ff6666;
}

.color-btn.active[data-color="blue"] {
  color: #3399ff;
  box-shadow: 0 0 15px #3399ff;
}

.color-btn.active[data-color="green"] {
  color: #33cc88;
  box-shadow: 0 0 15px #33cc88;
}

/* ======== 回路選択 ======== */
.palette {
    display: flex;
    gap: 18px;
    margin-top: 10px;
    justify-content: center;

}

.palette-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    min-width: 50px;
}

.palette-title,
.multi-title {
    font-size: 14px;
    font-weight: bold;
    margin-bottom: 4px;
    text-align: center;
    height: 22px;
    line-height: 1.5;
}

.symbol {
    width: 48px;
    height: 48px;
    border: 1px solid #333;
    font-size: 26px;
    background: #fff;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    user-select: none;
    border-radius: 5px;
}

.symbol.selected.red-active {
  background: #fff0f0;
  color: #ff6666;
  box-shadow: 0 0 15px #ff6666;
}

.symbol.selected.blue-active {
  background: #f0f8ff;
  color: #3399ff;
  box-shadow: 0 0 15px #3399ff;
}

.symbol.selected.green-active {
  background: #f0fff4;
  color: #33cc88;
  box-shadow: 0 0 15px #33cc88;
}

.symbol.multi {
    width: 46px;
    height: 46px;
    font-size: 26px;
    border: 2px dashed #333;
}

.num-edit-btn.selected.red-active {
  color: #ff6666;
  background: #fff0f0;
  box-shadow: 0 0 15px #ff6666;
}

.num-edit-btn.selected.blue-active {
  color: #3399ff;
  background: #f0f8ff;
  box-shadow: 0 0 15px #3399ff;
}

.num-edit-btn.selected.green-active {
  color: #33cc88;
  background: #f0fff4;
  box-shadow: 0 0 15px #33cc88;
}

.delete-btn.selected  {
    background: #fff0f0;
    color: #ff6666;
    box-shadow: 0 0 20px #ff6666;
}

.multi-label {
    position: absolute;
    top: 2px;
    right: 2px;
    font-size: 11px;
    font-weight: bold;
    color: #000;
}

/* ======== 合計 ======== */

.char-display {
    position: absolute;
    top: 2px;
    left: 2px;
    font-size: 11px;
    font-weight: bold;
    color: #000;
    pointer-events: none;
}
.char-sum-div {
  height: 70px; 
  max-height: 80px;
  overflow-y: auto;
  padding-right: 4px;
  margin-top: 4px;
  font-size: 12px;
}
.sum-header {
  font-weight: bold;
  margin-bottom: 2px;
    text-align:center;
}
.sum-name {
  text-align: left;
}

.sum-total{
  text-align:center;
}

.sum-multi {
  text-align: center ;
}

.sum-grid {
  display: grid;
  grid-template-columns: auto 60px 60px;
  column-gap: 6px;
  font-family: monospace;
  font-size: 12px;
}

/* ======== 数値選択 ======== */
.num-palette {
  display: grid;
  grid-template-columns: repeat(4, auto);
  gap: 10px 30px;
  margin-top: 6px;
  margin-bottom: 5px;
  justify-content: center;
}

.num-palette label:nth-child(3) {
  grid-column: 1;
}

.num-group {
    display: flex;
    gap: 6px;
    align-items: center;
}

/* ======== セーブスロット ======== */
.slot-buttons div {
    display: flex;
    gap: 4px;
    width: 100%;
    justify-content: stretch;
    align-items: center;
    margin-bottom: 6px;
    box-sizing: border-box;
}

.slot-name {
    flex: 1;
    height: 28px;
    box-sizing: border-box;
}

.slot-buttons button {
    height: 28px;
    box-sizing: border-box;
}

/* ======== 更新履歴 ======== */
.description {
    background: #f0f0f0;
    padding: 16px;
    border-radius: 10px;
    border: 2px solid #333;
    box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
    text-align: left;
    font-size: 14px;
    line-height: 1.4;
}

#changelog {
    width: 450px;
    height: 90px;
    background: #fefefe;
    border: 2px solid #333;
    border-radius: 4px;
    padding: 10px;
    font-family: monospace;
    font-size: 12px;
    overflow-y: auto;
    box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.3);
    box-sizing: border-box;
}

#changelog h4 {
    margin: 0 0 6px 0;
    font-size: 14px;
    text-align: left;
}

#changelog ul {
    padding-left: 6px;
    margin: 0;
    list-style: none;
    text-align: left;
}

#changelog li {
    margin-bottom: 4px;
}
.doc-btn {
  font-size: 10px;
  width: 26px;
  height: 26px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 5px;
  border: 1px solid #333;
  background: #fff;
  color: #000;

  text-align: center;
}
  </style>
</head>
<body>

  <div class="container">
    <div class="description-column">
      <div class="description">
        <h2>エクサスケイル防具 <br> 回路シミュレーター v1.82</h2>
        <p>
          ・色<br>
          ・回路<br>
          ・追加効果<br>
          ・数値<br>
          を右から選び、回路を配置して下さい。<br>
          追加効果が空白の場合は「指定なし」として計算されます。<br>
          リストに無い追加効果を付けたい場合は自由入力欄に入力して下さい。<br>
          <br>
          <span class="doc-btn">解除</span> …… 回路を非選択状態にします。<br>
          　　　　　同じ回路をもう一度クリックでも非選択にできます。<br>
          <br>
          <span class="doc-btn">変</span> …… 押すごとに表示が変わり、配置された回路をクリック
          　　　　　で、数値や追加効果を変更できます。<br>
          <span class="doc-btn">数</span> …… 数値だけを変更。<br>
          <span class="doc-btn">効</span> …… 追加効果だけを変更。<br>
          <span class="doc-btn">数/効</span> …… 数値と追加効果の両方を変更。<br>
          ※ 回路色はその時選択されている色に変更されます。<br>
          　 回路色だけを変更したい場合、色だけを選択して下さい。<br>
          <br>
          <span class="doc-btn">削</span> …… 配置した回路を削除できます。<br>
          　　　　　右クリックでも削除できます。<br>
          <br>
          ※ ローカルセーブ機能はありますが、安全のためにファイル出力<br>　 でデータを保存して下さい。<br>
        </p>
      </div>

      <div id="changelog">
        <h4>更新履歴</h4>
        <ul id="changelogList">
          <li>v1.82：一部修正</li>
          <li>v1.81：一部修正</li>
          <li>v1.80：色/数値/効果変更追加</li>
          <li>v1.75：テンプレ追加</li>
          <li>v1.74：テンプレ追加 + 一部修正</li>
          <li>v1.73：一部修正</li>
          <li>v1.72：一部修正</li>
          <li>v1.71：一部修正</li>
          <li>v1.70：テンプレ機能追加</li>
          <li>v1.62：一部修正</li>
          <li>v1.61：一部修正</li>
          <li>v1.60：追加効果追加</li>
          <li>v1.51：一部修正</li>
          <li>v1.50：レイアウト変更</li>
          <li>v1.42：一部修正</li>
          <li>v1.41：一部修正</li>
          <li>v1.40：複製回路追加</li>
          <li>v1.32：一部修正</li>
          <li>v1.31：一部修正</li>
          <li>v1.30：セーブ機能追加</li>
          <li>v1.20：ローカル保存機能追加</li>
          <li>v1.10：部位・数値追加</li>
          <li>v1.00：シミュ仮公開</li>
        </ul>
      </div>
    </div>

    <div class="left-frame" id="boards"></div>

    <div class="side">

      <div class="template-header">
      <h3>テンプレート</h3>
        <div class="pager">
          <button id="prevTemplate">◀</button>
          <span id="templatePageLabel">1 / 1</span>
          <button id="nextTemplate">▶</button>
        </div>
      </div>

      <div class="template-buttons" id="templateButtons"></div>
      <div class="palette" id="colorPalette"></div>
      <div class="palette" id="palette"></div>

      <h3>追加効果</h3>
      <select id="charSelect" style="width:220px;">
        
        <option value="持続ダメ" selected>持続ダメージ</option>
        <option value="CT初期化">スキルのCT初期化</option>
    
        <option value="両極化">両極化</option>
        <option value="以上ダメ">HP50%以上の敵攻撃時、ダメージ増加</option>
        <option value="以下ダメ">HP50%以下の敵攻撃時、ダメージ増加</option>
       
        <option value="スキダメ">柔軟、強靭、強烈、超越スキルダメージ増加</option>
   
        <option value="ボスダメ">ボスに与えるダメージ増加</option>
        <option value="PT動作速度">PTメンバーの動作速度</option>
      </select>
      <input
        id="charInput"
        type="text"
        maxlength="8"
        style="width:100px; text-align:center;"
        placeholder="自由入力 (任意)"
      />

      <h3>数値</h3>
      <div class="num-palette" id="numPalette">
        <label><input type="radio" name="num" value="0.5"> 0.5</label>
        <label><input type="radio" name="num" value="0.6"> 0.6</label>
        <label><input type="radio" name="num" value="0.7" checked> 0.7</label>
        <label><input type="radio" name="num" value="0.8"> 0.8</label>
        <label><input type="radio" name="num" value="0.9"> 0.9</label>
        <label><input type="radio" name="num" value="1.0"> 1.0</label>
      </div>

      <div class="template-header">

      <h3>セーブ</h3>
  <div></div>
  <div class="pager">
    <button id="prevSlot">◀</button>
    <span id="slotPageLabel">1 / 2</span>
    <button id="nextSlot">▶</button>
  </div>
</div>

<div class="slot-buttons" id="slotButtons"></div>
    </div>
  </div>
</body>
<script>
/* 
   1. 初期設定
 */
const partPos = { top: [3, 3], bottom: [0, 3], glove: [3, 0], shoes: [0, 0] };
const boardsEl = document.getElementById("boards");
const initialParts = ["top", "bottom", "glove", "shoes"];
let savedData = JSON.parse(localStorage.getItem("circuitBoards") || "null") || null;
let selectedColor = "red";
const size = 4;

const connections = {
  "┃": { l: 0, r: 0, u: 1, d: 1 },
  "━": { l: 1, r: 1, u: 0, d: 0 },
  "┗": { l: 0, r: 1, u: 1, d: 0 },
  "┏": { l: 0, r: 1, u: 0, d: 1 },
  "┓": { l: 1, r: 0, u: 0, d: 1 },
  "┛": { l: 1, r: 0, u: 1, d: 0 },
  "┳": { l: 1, r: 1, u: 0, d: 1 },
  "┻": { l: 1, r: 1, u: 1, d: 0 },
  "┣": { l: 0, r: 1, u: 1, d: 1 },
  "┫": { l: 1, r: 0, u: 1, d: 1 }
};


/* 
   2. かいろ
 */
const paletteData = [
  { title: "増幅回路", symbols: ["┃", "━", "変","削"], multi: false },
  { title: "増幅回路", symbols: ["┗", "┏", "┓", "┛"], multi: false, hideTitle: true },
  { title: "増幅回路", symbols: ["┳", "┫", "┻", "┣"], multi: false, hideTitle: true },
  { title: "複製回路", symbols: ["┳", "┫", "┻", "┣"], multi: true }
];

const templates = [
  {grid:[["┏","┓","┏","┓"],["┃","┗","┛","┃"],["┃","┏","┓","┃"],["┗","┛","┗","┛"]]},
  {grid:[["┏","━","━","┓"],["┗","┓","┏","┛"],["┏","┛","┗","┓"],["┗","━","━","┛"]]},
  {grid:[["┏","┳","┳","┓"],["┣","┫","┣","┫"],["┣","┫","┣","┫"],["┗","┻","┻","┛"]]},
  {grid:[["┏","┳","┳","┓"],["┣","┻","┻","┫"],["┣","┳","┳","┫"],["┗","┻","┻","┛"]]},

  {grid:[["┏","━","━","┓"],["┃","　","　","┃"],["┃","　","　","┃"],["┗","━","━","┛"]]},
  {grid:[["┏","┳","┳","┓"],["┣","┛","┗","┫"],["┣","┓","┏","┫"],["┗","┻","┻","┛"]]},
  {grid:[["┏","┳","┳","┓"],["┃","┃","┃","┃"],["┃","┃","┃","┃"],["┗","┻","┻","┛"]]},
  {grid:[["┏","━","━","┓"],["┣","━","━","┫"],["┣","━","━","┫"],["┗","━","━","┛"]]},

  {grid:[["┏","┓","┏","┓"],["┃","┃","┃","┃"],["┃","┗","┛","┃"],["┗","━","━","┛"]]},
  {grid:[["┏","━","━","┓"],["┃","┏","┓","┃"],["┃","┃","┃","┃"],["┗","┛","┗","┛"]]},
  {grid:[["┏","━","━","┓"],["┗","━","┓","┃"],["┏","━","┛","┃"],["┗","━","━","┛"]]},
  {grid:[["┏","━","━","┓"],["┃","┏","━","┛"],["┃","┗","━","┓"],["┗","━","━","┛"]]},
];

const TEMPLATES_PER_PAGE = 4;
let currentTemplatePage = 0;
const paletteEl = document.getElementById("palette");
const templateBtnContainer = document.getElementById("templateButtons");

const colorGroup = document.createElement("div");
colorGroup.className = "palette-group";

const colorTitle = document.createElement("div");
colorTitle.className = "multi-title";
colorTitle.textContent = "回路色";
colorGroup.appendChild(colorTitle);

paletteEl.appendChild(colorGroup);

paletteData.forEach(group => {
  const div = document.createElement("div");
  div.className = "palette-group";

  const titleDiv = document.createElement("div");
  titleDiv.className = "multi-title";
  if (group.hideTitle) titleDiv.style.visibility = "hidden";
  titleDiv.textContent = group.title;
  div.appendChild(titleDiv);

  group.symbols.forEach(sym => {
    const s = document.createElement("div");
    s.className = "symbol";
    if (sym === "変") s.classList.add("num-edit-btn");
    if (sym === "削") s.classList.add("delete-btn", "no-color-sync");
    if (group.multi) s.classList.add("multi");
    s.textContent = sym;
    div.appendChild(s);
  });

  paletteEl.appendChild(div);
});

function createTemplateLabel(grid) {
  return '<pre style="margin:0; font-size:12px; line-height:12px;">' +
         grid.map(row => row.join('')).join('\n') +
         '</pre>';
}

function renderTemplatePage() {
  templateBtnContainer.innerHTML = "";

  const start = currentTemplatePage * TEMPLATES_PER_PAGE;
  const end = start + TEMPLATES_PER_PAGE;
  const pageTemplates = templates.slice(start, end);

  pageTemplates.forEach(tpl => {
    const btn = document.createElement("div");
    btn.className = "template-btn";
    btn.innerHTML = createTemplateLabel(tpl.grid);
    btn.onclick = () => {
      selectButton(btn, "template", tpl);
      updateSelectedSymbolColor();
    };
    templateBtnContainer.appendChild(btn);
  });

  const totalPages = Math.ceil(templates.length / TEMPLATES_PER_PAGE);
  document.getElementById("templatePageLabel").textContent =
    (currentTemplatePage + 1) + " / " + totalPages;
  updateSelectedSymbolColor();
}


/* 
   3. 選択状態・入力
 */
const selectState = {
  type: null,
  value: null,
  isMulti: false,
  editMode: 0
};

function clearAllSelections() {
  document.querySelectorAll(".symbol, .template-btn")
    .forEach(b => b.classList.remove("selected"));

  const changeBtn = document.querySelector(".num-edit-btn");
  if (changeBtn) {
    changeBtn.textContent = "変";
    changeBtn.style.fontSize = "26px";
  }

  selectState.type = null;
  selectState.value = null;
  selectState.isMulti = false;
  selectState.editMode = 0;
}

function selectButton(el, type, value = null, isMulti = false) {
  const alreadySelected = el.classList.contains("selected");
  clearAllSelections();
  if (alreadySelected) return;

  el.classList.add("selected");
  selectState.type = type;
  selectState.value = value;
  selectState.isMulti = isMulti;
  updateSelectedSymbolColor();
  updateColorButtonsActive();
}

/*--------------------------------template--------------------------------*/
document.getElementById("prevTemplate").onclick = () => {
  const maxPage = Math.ceil(templates.length / TEMPLATES_PER_PAGE) - 1;
  currentTemplatePage = currentTemplatePage > 0 ? currentTemplatePage - 1 : maxPage;
  clearAllSelections();
  renderTemplatePage();
};
document.getElementById("nextTemplate").onclick = () => {
  const maxPage = Math.ceil(templates.length / TEMPLATES_PER_PAGE) - 1;
  currentTemplatePage = currentTemplatePage < maxPage ? currentTemplatePage + 1 : 0;
  clearAllSelections();
  renderTemplatePage();
};

/*--------------------------------color--------------------------------*/
function updateSelectedSymbolColor() {
  document.querySelectorAll(".symbol, .num-edit-btn").forEach(el => {
    if (el.classList.contains("no-color-sync")) return;
    el.classList.remove("red-active", "blue-active", "green-active");
    if (el.classList.contains("selected")) {
      el.classList.add(selectedColor + "-active");
    }
  });

  document.querySelectorAll(".template-btn").forEach(el => {
    el.classList.remove("red-active", "blue-active", "green-active");
    if (el.classList.contains("selected")) {
      el.classList.add(selectedColor + "-active");
      el.style.color = "";
    } else {
      let colorHex = selectedColor === "red" ? "#ff6666"
                   : selectedColor === "blue" ? "#3399ff"
                   : "#33cc88";
      el.style.color = colorHex;
    }
  });
}

function updateColorButtonsActive() {
  document.querySelectorAll(".color-btn").forEach(btn => {
    if (btn.dataset.color === selectedColor) {
      btn.classList.add("active");
    } else {
      btn.classList.remove("active");
    }
  });
}

["red","blue","green"].forEach(c => {
  const btn = document.createElement("div");
  btn.className = "color-btn" + (c === "red" ? " active" : "");
  btn.dataset.color = c;
  btn.textContent = c === "red" ? "演算" : c === "blue" ? "循環" : "復元";
  btn.style.background =
    c === "red" ? "#fff0f0" :
    c === "blue" ? "#f0f8ff" :
    "#f0fff4";
  btn.onclick = () => {
    const deleteSelected = selectState.type === "symbol" && selectState.value === "削";
    if (deleteSelected) {
      clearAllSelections();
    }
    document.querySelectorAll(".color-btn").forEach(b => b.classList.remove("active"));
    selectedColor = c;
    btn.classList.add("active");
    updateColorButtonsActive();
    updateSelectedSymbolColor();
  };
  colorGroup.appendChild(btn);
});

/*--------------------------------かいじょ--------------------------------*/
const clearSelectBtn = document.createElement("div");
clearSelectBtn.className = "color-btn";
clearSelectBtn.textContent = "解除";
clearSelectBtn.style.color = "#000";

clearSelectBtn.onclick = () => {
  clearAllSelections();
  updateSelectedSymbolColor();
  updateColorButtonsActive();

  clearSelectBtn.style.transition = "0.1s all";
  clearSelectBtn.style.transform = "scale(0.9)";


  setTimeout(() => {
    clearSelectBtn.style.transform = "scale(1)";
    clearSelectBtn.style.boxShadow = "";
  }, 100);
};

colorGroup.appendChild(clearSelectBtn);
/*--------------------------------change--------------------------------*/
function handleChangeButton(btn) {
  document.querySelectorAll(".symbol, .template-btn")
    .forEach(b => b.classList.remove("selected"));
  btn.classList.add("selected");
  selectState.type = "numEdit";
  selectState.editMode = (selectState.editMode + 1) % 4;
  if (selectState.editMode === 0) {
    selectState.type = null;
    btn.textContent = "変";
    btn.style.fontSize = "26px";
    btn.classList.remove("selected");
    return;
  }

  if (selectState.editMode === 1) {
    btn.textContent = "数";
    btn.style.fontSize = "26px";
  } else if (selectState.editMode === 2) {
    btn.textContent = "効";
    btn.style.fontSize = "26px";
  } else if (selectState.editMode === 3) {
    btn.textContent = "数/効";
    btn.style.fontSize = "16px";
  }
  updateSelectedSymbolColor();
  updateColorButtonsActive();
}

/*--------------------------------delete--------------------------------*/
document.querySelectorAll(".symbol").forEach(s => {
  s.onclick = () => {
    if (s.classList.contains("num-edit-btn")) {
      handleChangeButton(s);
      return;
    }
    if (s.classList.contains("delete-btn")) {
      const alreadySelected = s.classList.contains("selected");
      clearAllSelections();
    
      document.querySelectorAll(".color-btn").forEach(b => b.classList.remove("active"));
    
      if (!alreadySelected) {
        s.classList.add("selected");
        selectState.type = "symbol";
        selectState.value = "削";
        selectState.isMulti = false;
        updateSelectedSymbolColor();
      }
      return;
    }
    selectButton(s, "symbol", s.textContent, s.classList.contains("multi"));
  };
});

/*--------------------------------number--------------------------------*/
function getSelectedNumber() {
  const checked = document.querySelector('input[name="num"]:checked');
  return checked ? parseFloat(checked.value) : 0;
}

/*--------------------------------bui--------------------------------*/
const charInput = document.getElementById("charInput");
const charSelect = document.getElementById("charSelect");

function getSelectedChar() {
  return charInput.value.trim() || charSelect.value;
}

charInput.addEventListener("input", () => {
  if (charInput.value.trim() !== "") {
    charSelect.selectedIndex = 0;
  }
});

charSelect.addEventListener("change", () => {
  charInput.value = "";
});


/* 
   4. やばいところ
 */
renderTemplatePage();
const boards = [];

for (let i = 0; i < 4; i++) {
  let part = savedData?.[i]?.part || initialParts[i];
  const [px, py] = partPos[part];

  const grid = Array.from({ length: 4 }, () =>
    Array(4).fill(null).map(() => ({
      symbol: "",
      number: "",
      char: "",
      multi: false,
      color: "red"
    }))
  );

  grid[py][px] = { symbol: "img", number: "", multi: false };

  if (savedData?.[i]?.grid) {
    for (let y = 0; y < 4; y++) {
      for (let x = 0; x < 4; x++) {
        if (savedData[i].grid[y][x].symbol !== "img") {
          grid[y][x] = { ...savedData[i].grid[y][x] };
        }
      }
    }
  }

  const wrap = document.createElement("div");
  wrap.className = "board-wrap";
  wrap.charSumDiv = null;

  const panel = document.createElement("div");
  panel.className = "panel";
  panel.innerHTML = `
    <select class="part">
      <option value="top">上衣</option>
      <option value="bottom">下衣</option>
      <option value="glove">手袋</option>
      <option value="shoes">靴</option>
    </select>
  `;
  wrap.appendChild(panel);

  const clearBtn = document.createElement("button");
  clearBtn.textContent = "回路クリア";
  panel.appendChild(clearBtn);

  const board = document.createElement("div");
  board.className = "board";
  wrap.appendChild(board);

  const charSumDiv = document.createElement("div");
  charSumDiv.className = "char-sum-div";
  charSumDiv.textContent = "";
  wrap.appendChild(charSumDiv);
  wrap.charSumDiv = charSumDiv;

  panel.querySelector(".part").value = part;

  panel.querySelector(".part").onchange = () => {
    const p = panel.querySelector(".part").value;
    for (let y = 0; y < 4; y++)
      for (let x = 0; x < 4; x++)
        if (grid[y][x].symbol === "img") grid[y][x].symbol = "";
    const [x, y] = partPos[p];
    grid[y][x] = { symbol: "img", number: "", multi: false };
    drawBoard();
    saveBoards();
  };

  clearBtn.onclick = () => {
    if (confirm("回路を全て削除しますか？")) {
      for (let y = 0; y < 4; y++)
        for (let x = 0; x < 4; x++)
          if (grid[y][x].symbol !== "img")
            grid[y][x] = { symbol: "", number: "", multi: false };
      drawBoard();
      saveBoards();
    }
  };

  for (let y = 0; y < 4; y++) {
    for (let x = 0; x < 4; x++) {
      const c = document.createElement("div");
      c.className = "cell";

      c.onclick = () => {
        const cell = grid[y][x];
        if (cell.symbol === "img") return;
        if (!selectState.type && selectedColor && cell.symbol) {
          cell.color = selectedColor;
          drawBoard();
          saveBoards();
          return;
        }
        if (selectState.type === "numEdit") {
          if (!cell.symbol || cell.multi) return;
            if (selectedColor) {
              cell.color = selectedColor;
            }
            if (selectState.editMode === 1) {
              cell.number = getSelectedNumber();
            } else if (selectState.editMode === 2) {
              cell.char = getSelectedChar();
            } else if (selectState.editMode === 3) {
              cell.number = getSelectedNumber();
              cell.char = getSelectedChar();
            }
            drawBoard();
            saveBoards();
            return;
          }
        if (selectState.type === "template") {
          for (let ty = 0; ty < 4; ty++) {
            for (let tx = 0; tx < 4; tx++) {
              if (grid[ty][tx].symbol === "img") continue;
              const sym = selectState.value.grid[ty][tx];
              if (!sym || sym.trim() === "") {
                grid[ty][tx] = { symbol: "", number: "", char: "", multi: false, color: "red" };
              } else {
                grid[ty][tx] = {
                  symbol: sym,
                  number: getSelectedNumber(),
                  char: getSelectedChar(),
                  multi: false,
                  color: selectedColor
                };
              }
            }
          }
          drawBoard();
          saveBoards();
          return;
        }

        if (selectState.type === "symbol") {
          if (selectState.value === "削") {
            grid[y][x] = { symbol: "", number: "", char: "", multi: false, color: "red" };
          } else {
            grid[y][x] = {
              symbol: selectState.value,
              number: selectState.isMulti ? "" : getSelectedNumber(),
              char: selectState.isMulti ? "" : getSelectedChar(),
              multi: selectState.isMulti,
              color: selectedColor
            };
          }
          drawBoard();
          saveBoards();
        }
      };

      c.oncontextmenu = (e) => {
        e.preventDefault();
        const cell = grid[y][x];
        if (cell.symbol === "img") return;
        grid[y][x] = { symbol: "", number: "", char: "", multi: false, color: "red" };
        drawBoard();
        saveBoards();
      };

      board.appendChild(c);
    }
  }

  function drawBoard() {
    board.querySelectorAll(".cell").forEach((c, i) => {
      const y = Math.floor(i / 4);
      const x = i % 4;
      const s = grid[y][x];
      const part = panel.querySelector(".part").value;
      const circleImages = { top: "top.png", bottom: "bottom.png", glove: "glove.png", shoes: "shoes.png" };
      let symbolHTML = s.symbol;

      if (s.symbol === "img" && circleImages[part]) symbolHTML = `<img src="${circleImages[part]}" class="img">`;

      c.innerHTML = `
        <div class="symbol-display">${symbolHTML}</div>
        ${s.multi ? `<div class="multi-label">複</div>` : ``}
        <div class="char-display">${s.char || ""}</div>
        <div class="number-display">${s.number || ""}</div>
      `;
      c.className = "cell";
      if (!s.symbol) {
        c.style.background = "";
      } else if (s.multi) {
        c.style.background = "#ffffaa";
      } else if (s.color === "red") {
        c.style.background = "#fff0f0";
      } else if (s.color === "blue") {
        c.style.background = "#f0f8ff";
      } else if (s.color === "green") {
        c.style.background = "#f0fff4";
      } else {
        c.style.background = "";
      }
    });

    updateBoard();
  }

  function updateBoard() {
      const dx = { l: -1, r: 1, u: 0, d: 0 };
      const dy = { l: 0, r: 0, u: -1, d: 1 };
      const opp = { l: "r", r: "l", u: "d", d: "u" };
      const charOrder = Array.from(charSelect.options)
          .map(o => o.value)
          .filter(v => v !== "");

      let cx = -1, cy = -1;
      for (let y = 0; y < 4; y++) {
          for (let x = 0; x < 4; x++) {
              if (grid[y][x].symbol === "img") {
                  cx = x;
                  cy = y;
              }
          }
      }

      if (cx === -1) {
          board.querySelectorAll(".cell").forEach(c => c.className = "cell");
          wrap.charSumDiv.textContent = "";
          return;
      }

      const imgRoutes = [];

      for (const d in dx) {
          const nx = cx + dx[d];
          const ny = cy + dy[d];
          const t = grid[ny]?.[nx];

          if (
              t &&
              t.symbol &&
              connections[t.symbol] &&
              connections[t.symbol][opp[d]]
          ) {
              imgRoutes.push({ x: nx, y: ny, from: d });
          }
      }

      if (imgRoutes.length < 2) {
          board.querySelectorAll(".cell").forEach(c => c.className = "cell");
          wrap.charSumDiv.textContent = "";
          return;
      }

      function traceRoute(startX, startY, fromDir) {
          const visited = new Set();
          const stack = [{ x: startX, y: startY, from: fromDir }];

          while (stack.length) {
              const { x, y, from } = stack.pop();
              const key = x + "," + y;
              if (visited.has(key)) continue;
              visited.add(key);

              const s = grid[y][x];
              if (!s || !connections[s.symbol]) continue;

              for (const d in dx) {
                  if (d === from) continue;
                  if (!connections[s.symbol][d]) continue;

                  const nx = x + dx[d];
                  const ny = y + dy[d];
                  const t = grid[ny]?.[nx];
                  if (
                      t &&
                      t.symbol &&
                      connections[t.symbol] &&
                      connections[t.symbol][opp[d]]
                  ) {
                      stack.push({ x: nx, y: ny, from: opp[d] });
                  }
              }
          }

          return visited.size;
      }

      let validRoutes = 0;

      for (const r of imgRoutes) {
          const size = traceRoute(r.x, r.y, opp[r.from]);
          if (size >= 2) validRoutes++;
      }

      if (validRoutes < 2) {
          board.querySelectorAll(".cell").forEach(c => c.className = "cell");
          wrap.charSumDiv.textContent = "";
          return;
      }

      const visited = Array.from({ length: 4 }, () => Array(4).fill(false));
      const stack = [[cx, cy]];
      visited[cy][cx] = true;
      let invalid = false;

      while (stack.length && !invalid) {
          const [x, y] = stack.pop();
          const s = grid[y][x];

          for (const d in dx) {
              const nx = x + dx[d];
              const ny = y + dy[d];

              if (connections[s.symbol]?.[d]) {
                  if (nx < 0 || nx >= 4 || ny < 0 || ny >= 4) {
                      invalid = true;
                      break;
                  }
              }

              const t = grid[ny]?.[nx];
              if (!t) continue;

              if (s.symbol === "img") {
                  if (t.symbol && connections[t.symbol]) {
                      if (!connections[t.symbol]?.[opp[d]]) {
                          invalid = true;
                          break;
                      }
                      if (!visited[ny][nx]) {
                          visited[ny][nx] = true;
                          stack.push([nx, ny]);
                      }
                  }
                  continue;
              }

              if (connections[s.symbol]?.[d]) {
                  if (!t.symbol) {
                      invalid = true;
                      break;
                  }
                  if (t.symbol === "img") {
                      if (!visited[ny][nx]) {
                          visited[ny][nx] = true;
                          stack.push([nx, ny]);
                      }
                  } else {
                      if (!connections[t.symbol]?.[opp[d]]) {
                          invalid = true;
                          break;
                      }
                      if (!visited[ny][nx]) {
                          visited[ny][nx] = true;
                          stack.push([nx, ny]);
                      }
                  }
              }
          }
      }

      if (invalid) {
          board.querySelectorAll(".cell").forEach(c => c.className = "cell");
          wrap.charSumDiv.textContent = "";
          return;
      }

      const charSumTotal = {};
      const charSumMulti = {};

      board.querySelectorAll(".cell").forEach((c, i) => {
          const y = Math.floor(i / 4);
          const x = i % 4;
          const s = grid[y][x];

          c.className = "cell";
          if (!visited[y][x]) return;

          const cellCharValue = {};

          if (s.multi) {
              for (const d in dx) {
                  const nx = x + dx[d];
                  const ny = y + dy[d];
                  const t = grid[ny]?.[nx];

                  if (
                      t &&
                      visited[ny][nx] &&
                      !t.multi &&
                      t.number &&
                      connections[s.symbol]?.[d] &&
                      connections[t.symbol]?.[opp[d]]
                  ) {
                      const half = parseFloat(t.number) / 2;
                      const key = t.char && t.char.trim() !== "" ? t.char : "指定なし";
                      cellCharValue[key] = (cellCharValue[key] || 0) + half;
                  }
              }
          } else {
              const n = parseFloat(s.number);
              if (!isNaN(n)) {
                  const key = s.char && s.char.trim() !== "" ? s.char : "指定なし";
                  cellCharValue[key] = n;
              }
          }

          for (const ch in cellCharValue) {
              charSumTotal[ch] = (charSumTotal[ch] || 0) + cellCharValue[ch];
              if (s.multi) {
                  charSumMulti[ch] = (charSumMulti[ch] || 0) + cellCharValue[ch];
              }
          }

          if (connections[s.symbol]) {
              c.classList.add("connected", "highlight-" + (s.color || "red"));
          }
      });

      wrap.charSumDiv.innerHTML = `
          <div class="sum-grid sum-header">
              <div></div>
              <div>複製増加分</div>
              <div>合計</div>
          </div>
          <div class="sum-grid">
              ${
                  Object.entries(charSumTotal)
                      .sort((a, b) => {
                          if (b[1] !== a[1]) return b[1] - a[1];
                          const ia = charOrder.indexOf(a[0]);
                          const ib = charOrder.indexOf(b[0]);
                          if (a[0] === "指定なし") return 1;
                          if (b[0] === "指定なし") return -1;
                          return ia - ib;
                      })
                      .map(([k, v]) => {
                          const multi = charSumMulti[k] || 0;
                          return `
                              <div class="sum-name">${k}</div>
                              <div class="sum-multi">${multi > 0 ? multi.toFixed(2) : ""}</div>
                              <div class="sum-total">${v.toFixed(2)}</div>
                          `;
                      })
                      .join("")
              }
          </div>
      `;
  }

  wrap.drawBoard = drawBoard;
  wrap.grid = grid;
  wrap.panel = panel;
  boards.push(wrap);
  boardsEl.appendChild(wrap);
  drawBoard();
}


/* 
   5. 保存・スロット・EX/IN・履歴
 */
function saveBoards() {
  const data = boards.map(b => ({
    grid: b.grid.map(row =>
      row.map(cell => ({
        symbol: cell.symbol || "",
        number: cell.number || "",
        char: cell.char || "",
        multi: !!cell.multi,
        color: cell.color || "red"
      }))
    ),
    part: b.panel.querySelector(".part").value || "top"
  }));

  localStorage.setItem("circuitBoards", JSON.stringify(data));
}

/* ===== セーブスロット ===== */
const slotCount = 15;
const slotsPerPage = 5;
let currentSlotPage = 0;
const slotContainer = document.getElementById("slotButtons");

function renderSlotPage() {
  slotContainer.innerHTML = "";

  const start = currentSlotPage * slotsPerPage;
  const end = start + slotsPerPage;

  for (let i = start + 1; i <= Math.min(end, slotCount); i++) {
    const div = document.createElement("div");

    const input = document.createElement("input");
    input.type = "text";
    input.className = "slot-name";
    input.value = localStorage.getItem("circuitBoards_slot" + i + "_name") || ("スロット" + i);
    div.appendChild(input);

    const saveBtn = document.createElement("button");
    saveBtn.className = "saveBtn";
    saveBtn.dataset.slot = i;
    saveBtn.textContent = "保存";
    div.appendChild(saveBtn);

    const loadBtn = document.createElement("button");
    loadBtn.className = "loadBtn";
    loadBtn.dataset.slot = i;
    loadBtn.textContent = "読み込み";
    div.appendChild(loadBtn);

    slotContainer.appendChild(div);
  }

  const totalPages = Math.ceil(slotCount / slotsPerPage);
  document.getElementById("slotPageLabel").textContent =
    (currentSlotPage + 1) + " / " + totalPages;

  attachSlotEvents();
}

function attachSlotEvents() {
  document.querySelectorAll(".saveBtn").forEach(btn => {
    btn.onclick = () => {
      const slot = btn.dataset.slot;
      const slotDiv = btn.parentElement;
      const slotName = slotDiv.querySelector(".slot-name").value || ("スロット" + slot);

      try {
        const saveData = boards.map(b => ({
          grid: b.grid.map(row =>
            row.map(cell => ({
              symbol: cell.symbol || "",
              number: cell.number || "",
              char: cell.char || "",
              multi: !!cell.multi,
              color: cell.color || "red"
            }))
          ),
          part: b.panel.querySelector(".part").value || "top"
        }));

        localStorage.setItem("circuitBoards_slot" + slot, JSON.stringify(saveData));
        localStorage.setItem("circuitBoards_slot" + slot + "_name", slotName);
        addChangelog(slotName + " に保存しました : " + new Date().toLocaleString());
      } catch (e) {
        alert("保存に失敗しました : " + e.message);
      }
    };
  });

  document.querySelectorAll(".loadBtn").forEach(btn => {
    btn.onclick = () => {
      const slot = btn.dataset.slot;
      const data = localStorage.getItem("circuitBoards_slot" + slot);
      const slotName = localStorage.getItem("circuitBoards_slot" + slot + "_name") || ("スロット" + slot);

      if (!data) {
        alert(slotName + " は空です");
        return;
      }

      try {
        const parsed = JSON.parse(data);
        parsed.forEach((d, i) => {
          for (let y = 0; y < 4; y++)
            for (let x = 0; x < 4; x++)
              boards[i].grid[y][x] = { ...d.grid[y][x] };

          boards[i].panel.querySelector(".part").value = d.part || "top";
          boards[i].drawBoard();
        });

        addChangelog(slotName + " から読み込みました : " + new Date().toLocaleString());
      } catch (e) {
        alert(slotName + " のデータが壊れています");
      }
    };
  });
}

document.getElementById("prevSlot").onclick = () => {
  const maxPage = Math.ceil(slotCount / slotsPerPage) - 1;
  currentSlotPage = currentSlotPage > 0 ? currentSlotPage - 1 : maxPage;
  renderSlotPage();
};

document.getElementById("nextSlot").onclick = () => {
  const maxPage = Math.ceil(slotCount / slotsPerPage) - 1;
  currentSlotPage = currentSlotPage < maxPage ? currentSlotPage + 1 : 0;
  renderSlotPage();
};

renderSlotPage();

/* ===== EX/IN ===== */
const exportAllBtn = document.createElement("button");
exportAllBtn.textContent = "ファイル出力";
const importAllBtn = document.createElement("button");
importAllBtn.textContent = "ファイル読み込み";
const importAllFile = document.createElement("input");
importAllFile.type = "file";
importAllFile.accept = ".txt";
importAllFile.style.display = "none";

document.querySelector(".side").appendChild(exportAllBtn);
document.querySelector(".side").appendChild(importAllBtn);
document.querySelector(".side").appendChild(importAllFile);
exportAllBtn.style.width = "150px";
importAllBtn.style.width = "150px";
exportAllBtn.style.marginRight = "12px";

exportAllBtn.onclick = () => {
  try {
    const slotsData = {};
    for (let i = 1; i <= 5; i++) {
      const slotName = localStorage.getItem("circuitBoards_slot" + i + "_name") || ("スロット" + i);
      const slotData = localStorage.getItem("circuitBoards_slot" + i) || null;
      slotsData[i] = { name: slotName, data: slotData };
    }

    const boardsData = boards.map(b => ({
      grid: b.grid.map(r => r.map(c => ({
        symbol: c.symbol || "",
        number: c.number || "",
        char: c.char || "",
        multi: !!c.multi,
        color: c.color || "red"
      }))),
      part: b.panel.querySelector(".part").value || "top"
    }));

    const exportData = { boards: boardsData, slots: slotsData };
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: "text/plain" });

    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "circuitSimulator.txt";
    a.click();
    URL.revokeObjectURL(url);

    const now = new Date().toLocaleString();
    addChangelog(`ファイルを保存しました : ${now}`);
  } catch (err) {
    alert("エクスポート出来ませんでした : " + err.message);
    console.error(err);
  }
};

importAllBtn.onclick = () => importAllFile.click();

importAllFile.onchange = (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (evt) => {
    try {
      const parsed = JSON.parse(evt.target.result);

      if (parsed.boards && Array.isArray(parsed.boards)) {
        parsed.boards.forEach((d, i) => {
          for (let y = 0; y < 4; y++)
            for (let x = 0; x < 4; x++)
              boards[i].grid[y][x] = { ...d.grid[y][x] };
          boards[i].panel.querySelector(".part").value = d.part || "top";
          boards[i].drawBoard();
        });
      }

      if (parsed.slots) {
        for (let i = 1; i <= 5; i++) {
          if (parsed.slots[i]) {
            localStorage.setItem("circuitBoards_slot" + i, parsed.slots[i].data || null);
            localStorage.setItem("circuitBoards_slot" + i + "_name", parsed.slots[i].name || ("スロット" + i));
            const slotDiv = document.querySelectorAll(".slot-buttons div")[i - 1];
            slotDiv.querySelector(".slot-name").value = parsed.slots[i].name || ("スロット" + i);
          }
        }
      }

      const now = new Date().toLocaleString();
      addChangelog(`${file.name} を読み込みました : ${now}`);
    } catch (err) {
      alert("ファイルが正しくありません : " + err.message);
      console.error(err);
    }
  };
  reader.readAsText(file, "UTF-8");
  importAllFile.value = "";
};

function addChangelog(text) {
  const ul = document.getElementById("changelogList");
  const li = document.createElement("li");
  li.textContent = text;
  ul.prepend(li);
}
</script>
